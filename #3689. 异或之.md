
### Description
给定n个非负整数A[1], A[2], ……, A[n]。
对于每对(i, j)满足1 <= i < j <= n，得到一个新的数A[i] xor A[j]，这样共有n*(n-1)/2个新的数。求这些数（不包含A[i]）中前k小的数。
注：xor对应于pascal中的“xor”，C++中的“^”。

### Input
第一行2个正整数 n,k，如题所述。
以下n行，每行一个非负整数表示A[i]。

### Output
 共一行k个数，表示前k小的数。

### Sample Input
4 5
1
1
3
4

### Sample Output
0 2 2 5 5

### Hint
【样例解释】
1 xor 1 = 0 (A[1] xor A[2])
1 xor 3 = 2 (A[1] xor A[3])
1 xor 4 = 5 (A[1] xor A[4])
1 xor 3 = 2 (A[2] xor A[3])
1 xor 4 = 5 (A[2] xor A[4])
3 xor 4 = 7 (A[3] xor A[4])
前5小的数：0 2 2 5 5
【数据范围】
 对于100%的数据，2 <= n <= 100000； 1 <= k <= min{250000, n*(n-1)/2}；
        0 <= A[i] < 2^31

### Source
